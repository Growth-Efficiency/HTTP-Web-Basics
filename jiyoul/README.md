※ 1일차 ※

TCP :
- 연결지향 - TCP 3 way handshake (가상 연결)
  -> 1. 상대에게 접속 요청을 보냄.
  -> 2. 요청 수락 및 접속 요청을 나에게 보냄.
  -> 3. 요청 수락 및 데이터 전송가능.
- 데이터 전달 보증
  -> 데이터 전송하면 데이터 잘 받았다고 결과를 줌.
- 순서보장
  -> 패킷1, 패킷3, 패킷2 이렇게 들어올 경우 패킷2부터 다시 보내라고 함.

UDP :
- 하얀 도화지와 같다(기능이 거의 없음)
- TCP는 이미 기반으로 쓰고 있기 때문에 개인적으로 최적화 등 쓰고 바꿔 쓰고 싶을때 사용한다.

PORT
TCP/IP 패킷내에 출발지IP와 PORT가 있고 해당 정보를 꺼내서 찾는다.
아파트의 몇호 처럼 한IP가 아파트, 한 PC가 한 호라고 생각하면 된다.

DNS
DNS서버에 도메인을 돈주고 사면 IP대신 도메인 명으로 사용할 수 있다.


URI(Uniform Resource Identifier)
Uniform : 리소스를 식별하는 통일된 방식
Resource : 자원, URI로 식별할 수 있는 모든것(제한 없음)
- 실시간 교통정보라던가 구분할 수 있는 모든 정보.
  Identifier : 다른 항목과 구분하는데 필요한 정보
- 주문번호로 구분한다던가 하면 주문번호가 Identifier가 될 수 있음.

- URI 라는 가장 큰 개념이 있다.
- URI는 URL(로테이터 = locator), URN(이름 = name) 또는 둘다로 분류될 수 있다.

URL(Uniform Resourcec Locator)
- 리소스가 있는 위치를 지정한다.
- URL은 변할 수 있다.
  URN(Uninform Resource Name)
- 리소스에 이름을 부여한다.
- URN은 변하지 않는다.
- URN 이름만으로 실제 리소스를 찾는 방법이 보편화 되있지 않다.

http는 80포트, https는 443포트를 주로 사용한다.

![저장](https://user-images.githubusercontent.com/54700818/159712523-df3f42ea-dc87-4d6d-9f7f-6f7400bbb599.PNG)

----------------------------------------------------------------------------------------------------------------------

※ 2일차 ※

Stateful : 상태유지
- 중간에 다른 점원으로 바뀌면 안된다.
- 로그인해야 되는 페이지.(브라우저 쿠키와 서버 세션 등)
- 상태유지는 최소한만 사용.
  Stateless : 무상태
- 갑자기 고객이 증가해도 점원을 대거 투입할 수 있다.
- 예를들면 단순한 이벤트 소개하는 페이지
- 데이터를 너무 많이 먹음.

비 연결성(connectionless)
- HTTP는 기본적으로 연결이 유지되지 않음.
- 서버의 자원을 효율적으로 사용 할 수 있음.
- TCP/IP 연결을 새로 맺어야 함.(3 way handshake 시간 추가.)
  -> 지금은 HTTP의 지속연결로 해결함.

지금은 HTTP 시대이다.

----------------------------------------------------------------------------------------------------------------------

※ 3일차 ※

Representation리소스란 무엇일까?
회원 등록시 회원이라는 개념 자체가 리소스이다.

리소스를 식별하는것이 가장 중요한데.(URI는 리소스만 식별해야 한다.)

회원 등록, 수정, 조회등의 URI를 설계하는것을 배제하고
회원이라는 리소스만 식별하여 URI에 매핑해야 한다.

GET : 리소스 조회
- 클라이언트가 리소스의 위치를 모름.
  POST : 주로 리소스 등록(요청 데이터 처리)
- 클라이언트가 리소스의 위치를 모름.
- 신규 등록
- 단순히 데이터를 생성하거나 변경하는것을 넘어선 프로세스를 처리해야 할 경우.
- JSON으로 조회 데이터를 넘겨야 해서 GET으로는 사용하기 어려울경우.
  PUT : 리소스 대체(없으면 생성)
- (중요) 클라이언트가 리소스의 위치를 알고 URI로 지정함.
- 폴더에 파일을 덮어씌우듯 완전히 대체함.
- 다른 필드 값이든 뭐든 그냥 내가 보낸 데이터로 완전히 덮어씌워버림(기존껀 싹 없애버림)
  PATCH : 리소스 부분 변경
- (중요) 클라이언트가 리소스의 위치를 알고 URI로 지정함.
- 리소스의 부분 값을 바꾸고 싶으면 PATCH를 쓰면 됨.
  DELETE : 리소스 삭제
- (중요) 클라이언트가 리소스의 위치를 알고 URI로 지정함.
- 리소스를 삭제함.

HEAD : GET과 동일.(결과값은 상태줄과 헤더만 줘)
OPTIONS : 리소스에 대한 통신 가능 옵션을 설명 -> 주로 CORS에서 사용
CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정 -> 잘 사용하지 않음.
TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행 -> 잘 사용하지 않음.

![http](https://user-images.githubusercontent.com/54700818/160238332-8b32db75-fbb2-400d-ad88-825146b4b27e.PNG)

안전(Safe) : 여러번 호출했을때 리소스가 변하지 않아야 한다.
멱등(Idempotent) : 한번 호출하든 100번 호출하든 결과가 같아야 한다.
- (실행 응답 결과가 오지 않았을때 자동으로 다시 실행 시켜도 되는지 같은 경우.)
- (예를들면 GET등 외부요인으로 중간에 리소스가 변경되는것 까지는 판단하지 않음.)
- GET : 같은 요청을 하면 같은 값이므로 결과가 멱등함.
- PUT : 같은 요청을 해도 항상 같은 값을 대체하므로 결과가 멱등함.
- DELETE : 결과를 삭제하는건 같으므로 여러번 삭제해도 결과가 멱등함.
- POST : 멱등이 아님! 중복해서 로직등이 실행 됨.

캐시가능(Cacheable) : 응답 결과를 캐쉬에서 사용할 수 있는지.
- GET, HEAD, POST, PATCH는 캐쉬 가능.
- 실제로는 GET, HEAD 정도만 캐쉬로 사용함.
- POST, PATCH는 body 내용도 구별을 해야하기 때문에 잘 구현해놓지 않음.

클라이언트에서 서버로 데이터 전송시 4가지 상황
1. 정적 데이터 조회(이미지, 텍스트 등)
- 조회는 GET사용.
- 보통 쿼리 파마리터 없이 리소스 경로로 단순하게 조회.
2. 동적 데이터 조회
- 조회는 GET사용.
- 쿼리 파마리터 사용.
- 주로 검색, 게시판 목록에서 정렬 필터(검색어)
3. HTML Form 데이터 전송
- <form action="/save" method="get">안에 username, age가 <input> 태그이면 GET /save?username=kim&age=20 HTTP/1.1 이런식으로 생성됨.
- action = URI, method = GET,POST 등.
- POST의 경우 body username=kim&age=20가 생성됨.
- <form>에 enctype="multipart/form-data"를 넣으면 파일도 전송이 가능하다.

4. HTTP API 데이터 전송
- 서버끼리 통실 할 때 사용.(기계끼리 통신)
- 앱 클라이언트(아이폰, 안드로이드)
- 웹 클라이언트(자바스크립트를 통한 통신 : Ajax)
  -> 메시지 body를 통해 데이터 전송.(POST, PUT, PATCH)
  -> 쿼리 파라미터로 데이터 전달.(GET, 정렬 검색)

----------------------------------------------------------------------------------------------------------------------

※ 4일차 ※

회원관리 시스템 : 클라이언트가 새로 리소스를 등록시.
POST 방법
- 클라이언트는 등록 될 리소스의 URI를 모른다.
- 서버가 새로 등록된 리소스의 URI를 생성하고 관리해준다.
- POST 기반으로 등록할때 서버가 리소스의 URI를 생성하고 관리하는 디렉토리를 컬렉션(Collection)이라고 한다.

파일 관리 시스템 : 클라이언트가 새로 리소스를 등록시.
PUT 방법
- PUT 기반으로 저장하는것을 스토어(Store) 라고 한다.
- 클라이언트는 등록 될 리소스를 알고 있다.

HTML FORM 사용
- 순수 HTML + HTML form 사용
- GET, POST만 지원.

상태코드
100번때 : 요청이 수신되어 처리중(잘안쓰임).
200번때 : 요청이 정상 처리 되었을때.
- 200 (OK)            : 요청이 정상 처리됨.
- 201 (Created)      : 요청이 성공해서 새로운 리소스가 생성됨.
- 202 (Accepted)    : 요청이 처리되었으나 처리가 완료되지 않음.
- 204 (No Content) : 요청을 성공적으로 수행했지만 응답 페이로드 본문에 보낼 데이터가 없음.
  300번때 : 요청을 완료하기위해 클라이언트의 추가행동이 필요할때.(HTTP 리다이렉션)
- 300 (Multiple Choices) : 안쓰임.
- 301 (Move Permanently) : 리다이렉트 요청 메서스가 GET으로 변하고, 본문이 제거될 수 있음.
- 302 (Found) : 리다이렉트시 요청 메서드가 GET으로 변하거나, 본문이 제거 될 수도 있다.
- 303 (See Other) : 302와 동일하나 리다이렉트시 요청 메서드가 무조건 GET으로 변한다.(실무에선 주로 302을 주로 사용함.)
- 304 (Not Modified) :
  -> 캐시를 목적으로 사용
  -> 클라이언트에게 리소스가 수정되지 않았음을 알려준다.(따라서 클라이언트는 로컬PC에 저장된 캐시를 재사용함.)
  -> 304 응답은 응답에 메시지 바디를 포함하면 안된다.
  -> 조건부 GET, HEAD 요청시 사용
- 307 (Temporary Redirect) : 302와 동일하나 리다이렉트시 요청 메서드와 본문 유지.(실무에선 주로 302을 주로 사용함.)
- 308 (Permanent Redirect) : 301과 동일하나 요청 메서드와 본문 유지.(실무에선 주로 301을 주로 사용함.)
  400번때 : 클라이언트 오류, 잘못된 문법등으로 서버가 요철을 수행하지 못할때.
- 400 (Bad Request) : 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음.
  -> 요청구문, 메시지 등 오류
  -> 클라이언트는 요청 내용을 다시 검토하고 보내야함.
  -> 요청 파라미터가 잘못되거나 API 스펙이 맞지 않을때.
- 401 (Unauthorized) : 클라이언트가 해당 리소스에 대한 인증이 필요함.
  -> 인증(Authentication) 되지 않음. (본인이 누구인지 확인 = 로그인과 같은)
  -> 오류 발생시 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명한다.
- 403 (Forbidden) : 서버가 요청을 이해했지만 승인을 거부함.
  -> 주로 이 에러는 인증 자격 증명은 있지만, 접근 권한이 불충분한 경우에 발생.
  -> 예를들면 어드민 등급이 아닌 사용자가 어드민 권한에 접근할때.
- 404 (Not Found) : 요청 리소스를 찾을 수 없음.
  -> 요청 리소스가 서버에 없을때.
  -> 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을 때.
  500번때 : 서버의 내부적이 오류로 서버가 정상 요청을 처리하지 못할때.
- 500 (Internal Server Error) : 서버 문제로 오류 발생, 애매하면 500 오류
  -> 서버 내부 문제로 오류 발생할 때.
  -> 애매한 오류면 500에러내기.
- 503 (Service Unavailable) : 서비스 이용 불가.
  -> 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없을때.
  -> Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼수도 있다.

리다이렉션이란
- 영구 리다이렉션 : 특정 리소스의 URI가 영구적으로 이동.(301, 308)
- 일시 리다이렉션 : 특정 리소스의 URI가 일시적인 변경.(302, 303, 307)
* PRG(Post/Redirect/Get) : 일시적인 리다이렉션 예시
  1. (클라) 서버로 POST /order URL을 호출하여 주문.
  2. (서버) DB에 주문데이터 저장(mouse)
  3. (서버) 응답 데이터로 클라이언트에 URL : /order-result/10 이라고 전송(10은 mouse 생성된 값)
  4. (클라) 받은 값으로 자동 리다이렉트됨.
  5. (클라) 받은 URL 값으로 서버에 GET으로 /order-result/10를 전송.
  6. (서버) DB에 주문데이터 10번 조회.
  7. (서버) 클라이언트로 200 OK 응답.
  8. (클라) 결과화면에서 새로고침해도 GET /order-result/10 결과만 다시 요청됨.(5번 반복)
  9. 결과적으로 일시적 리다이렉션을 통해 재 주문이 되지않음.
- 특수 리다이렉션 : 결과 대신 캐시를 사용.(300, 304)











