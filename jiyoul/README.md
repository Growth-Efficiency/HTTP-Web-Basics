※ 1일차 ※

TCP :
- 연결지향 - TCP 3 way handshake (가상 연결)
  -> 1. 상대에게 접속 요청을 보냄.
  -> 2. 요청 수락 및 접속 요청을 나에게 보냄.
  -> 3. 요청 수락 및 데이터 전송가능.
- 데이터 전달 보증
  -> 데이터 전송하면 데이터 잘 받았다고 결과를 줌.
- 순서보장
  -> 패킷1, 패킷3, 패킷2 이렇게 들어올 경우 패킷2부터 다시 보내라고 함.

UDP :
- 하얀 도화지와 같다(기능이 거의 없음)
- TCP는 이미 기반으로 쓰고 있기 때문에 개인적으로 최적화 등 쓰고 바꿔 쓰고 싶을때 사용한다.

PORT
TCP/IP 패킷내에 출발지IP와 PORT가 있고 해당 정보를 꺼내서 찾는다.
아파트의 몇호 처럼 한IP가 아파트, 한 PC가 한 호라고 생각하면 된다.

DNS
DNS서버에 도메인을 돈주고 사면 IP대신 도메인 명으로 사용할 수 있다.


URI(Uniform Resource Identifier)
Uniform : 리소스를 식별하는 통일된 방식
Resource : 자원, URI로 식별할 수 있는 모든것(제한 없음)
- 실시간 교통정보라던가 구분할 수 있는 모든 정보.
  Identifier : 다른 항목과 구분하는데 필요한 정보
- 주문번호로 구분한다던가 하면 주문번호가 Identifier가 될 수 있음.

- URI 라는 가장 큰 개념이 있다.
- URI는 URL(로테이터 = locator), URN(이름 = name) 또는 둘다로 분류될 수 있다.

URL(Uniform Resourcec Locator)
- 리소스가 있는 위치를 지정한다.
- URL은 변할 수 있다.
  URN(Uninform Resource Name)
- 리소스에 이름을 부여한다.
- URN은 변하지 않는다.
- URN 이름만으로 실제 리소스를 찾는 방법이 보편화 되있지 않다.

http는 80포트, https는 443포트를 주로 사용한다.

![저장](https://user-images.githubusercontent.com/54700818/159712523-df3f42ea-dc87-4d6d-9f7f-6f7400bbb599.PNG)

----------------------------------------------------------------------------------------------------------------------

※ 2일차 ※

Stateful : 상태유지
- 중간에 다른 점원으로 바뀌면 안된다.
- 로그인해야 되는 페이지.(브라우저 쿠키와 서버 세션 등)
- 상태유지는 최소한만 사용.
  Stateless : 무상태
- 갑자기 고객이 증가해도 점원을 대거 투입할 수 있다.
- 예를들면 단순한 이벤트 소개하는 페이지
- 데이터를 너무 많이 먹음.

비 연결성(connectionless)
- HTTP는 기본적으로 연결이 유지되지 않음.
- 서버의 자원을 효율적으로 사용 할 수 있음.
- TCP/IP 연결을 새로 맺어야 함.(3 way handshake 시간 추가.)
  -> 지금은 HTTP의 지속연결로 해결함.

지금은 HTTP 시대이다.

----------------------------------------------------------------------------------------------------------------------

※ 3일차 ※

Representation리소스란 무엇일까?
회원 등록시 회원이라는 개념 자체가 리소스이다.

리소스를 식별하는것이 가장 중요한데.(URI는 리소스만 식별해야 한다.)

회원 등록, 수정, 조회등의 URI를 설계하는것을 배제하고
회원이라는 리소스만 식별하여 URI에 매핑해야 한다.

GET : 리소스 조회
- 클라이언트가 리소스의 위치를 모름.
  POST : 주로 리소스 등록(요청 데이터 처리)
- 클라이언트가 리소스의 위치를 모름.
- 신규 등록
- 단순히 데이터를 생성하거나 변경하는것을 넘어선 프로세스를 처리해야 할 경우.
- JSON으로 조회 데이터를 넘겨야 해서 GET으로는 사용하기 어려울경우.
  PUT : 리소스 대체(없으면 생성)
- (중요) 클라이언트가 리소스의 위치를 알고 URI로 지정함.
- 폴더에 파일을 덮어씌우듯 완전히 대체함.
- 다른 필드 값이든 뭐든 그냥 내가 보낸 데이터로 완전히 덮어씌워버림(기존껀 싹 없애버림)
  PATCH : 리소스 부분 변경
- (중요) 클라이언트가 리소스의 위치를 알고 URI로 지정함.
- 리소스의 부분 값을 바꾸고 싶으면 PATCH를 쓰면 됨.
  DELETE : 리소스 삭제
- (중요) 클라이언트가 리소스의 위치를 알고 URI로 지정함.
- 리소스를 삭제함.

HEAD : GET과 동일.(결과값은 상태줄과 헤더만 줘)
OPTIONS : 리소스에 대한 통신 가능 옵션을 설명 -> 주로 CORS에서 사용
CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정 -> 잘 사용하지 않음.
TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행 -> 잘 사용하지 않음.

![http](https://user-images.githubusercontent.com/54700818/160238332-8b32db75-fbb2-400d-ad88-825146b4b27e.PNG)

안전(Safe) : 여러번 호출했을때 리소스가 변하지 않아야 한다.
멱등(Idempotent) : 한번 호출하든 100번 호출하든 결과가 같아야 한다.
- (실행 응답 결과가 오지 않았을때 자동으로 다시 실행 시켜도 되는지 같은 경우.)
- (예를들면 GET등 외부요인으로 중간에 리소스가 변경되는것 까지는 판단하지 않음.)
- GET : 같은 요청을 하면 같은 값이므로 결과가 멱등함.
- PUT : 같은 요청을 해도 항상 같은 값을 대체하므로 결과가 멱등함.
- DELETE : 결과를 삭제하는건 같으므로 여러번 삭제해도 결과가 멱등함.
- POST : 멱등이 아님! 중복해서 로직등이 실행 됨.

캐시가능(Cacheable) : 응답 결과를 캐쉬에서 사용할 수 있는지.
- GET, HEAD, POST, PATCH는 캐쉬 가능.
- 실제로는 GET, HEAD 정도만 캐쉬로 사용함.
- POST, PATCH는 body 내용도 구별을 해야하기 때문에 잘 구현해놓지 않음.

클라이언트에서 서버로 데이터 전송시 4가지 상황
1. 정적 데이터 조회(이미지, 텍스트 등)
- 조회는 GET사용.
- 보통 쿼리 파마리터 없이 리소스 경로로 단순하게 조회.
2. 동적 데이터 조회
- 조회는 GET사용.
- 쿼리 파마리터 사용.
- 주로 검색, 게시판 목록에서 정렬 필터(검색어)
3. HTML Form 데이터 전송
- <form action="/save" method="get">안에 username, age가 <input> 태그이면 GET /save?username=kim&age=20 HTTP/1.1 이런식으로 생성됨.
- action = URI, method = GET,POST 등.
- POST의 경우 body username=kim&age=20가 생성됨.
- <form>에 enctype="multipart/form-data"를 넣으면 파일도 전송이 가능하다.

4. HTTP API 데이터 전송
- 서버끼리 통실 할 때 사용.(기계끼리 통신)
- 앱 클라이언트(아이폰, 안드로이드)
- 웹 클라이언트(자바스크립트를 통한 통신 : Ajax)
  -> 메시지 body를 통해 데이터 전송.(POST, PUT, PATCH)
  -> 쿼리 파라미터로 데이터 전달.(GET, 정렬 검색)

----------------------------------------------------------------------------------------------------------------------

※ 4일차 ※

회원관리 시스템 : 클라이언트가 새로 리소스를 등록시.
POST 방법
- 클라이언트는 등록 될 리소스의 URI를 모른다.
- 서버가 새로 등록된 리소스의 URI를 생성하고 관리해준다.
- POST 기반으로 등록할때 서버가 리소스의 URI를 생성하고 관리하는 디렉토리를 컬렉션(Collection)이라고 한다.

파일 관리 시스템 : 클라이언트가 새로 리소스를 등록시.
PUT 방법
- PUT 기반으로 저장하는것을 스토어(Store) 라고 한다.
- 클라이언트는 등록 될 리소스를 알고 있다.

HTML FORM 사용
- 순수 HTML + HTML form 사용
- GET, POST만 지원.

상태코드
100번때 : 요청이 수신되어 처리중(잘안쓰임).
200번때 : 요청이 정상 처리 되었을때.
- 200 (OK)            : 요청이 정상 처리됨.
- 201 (Created)      : 요청이 성공해서 새로운 리소스가 생성됨.
- 202 (Accepted)    : 요청이 처리되었으나 처리가 완료되지 않음.
- 204 (No Content) : 요청을 성공적으로 수행했지만 응답 페이로드 본문에 보낼 데이터가 없음.
  300번때 : 요청을 완료하기위해 클라이언트의 추가행동이 필요할때.(HTTP 리다이렉션)
- 300 (Multiple Choices) : 안쓰임.
- 301 (Move Permanently) : 리다이렉트 요청 메서스가 GET으로 변하고, 본문이 제거될 수 있음.
- 302 (Found) : 리다이렉트시 요청 메서드가 GET으로 변하거나, 본문이 제거 될 수도 있다.
- 303 (See Other) : 302와 동일하나 리다이렉트시 요청 메서드가 무조건 GET으로 변한다.(실무에선 주로 302을 주로 사용함.)
- 304 (Not Modified) :
  -> 캐시를 목적으로 사용
  -> 클라이언트에게 리소스가 수정되지 않았음을 알려준다.(따라서 클라이언트는 로컬PC에 저장된 캐시를 재사용함.)
  -> 304 응답은 응답에 메시지 바디를 포함하면 안된다.
  -> 조건부 GET, HEAD 요청시 사용
- 307 (Temporary Redirect) : 302와 동일하나 리다이렉트시 요청 메서드와 본문 유지.(실무에선 주로 302을 주로 사용함.)
- 308 (Permanent Redirect) : 301과 동일하나 요청 메서드와 본문 유지.(실무에선 주로 301을 주로 사용함.)
  400번때 : 클라이언트 오류, 잘못된 문법등으로 서버가 요철을 수행하지 못할때.
- 400 (Bad Request) : 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음.
  -> 요청구문, 메시지 등 오류
  -> 클라이언트는 요청 내용을 다시 검토하고 보내야함.
  -> 요청 파라미터가 잘못되거나 API 스펙이 맞지 않을때.
- 401 (Unauthorized) : 클라이언트가 해당 리소스에 대한 인증이 필요함.
  -> 인증(Authentication) 되지 않음. (본인이 누구인지 확인 = 로그인과 같은)
  -> 오류 발생시 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명한다.
- 403 (Forbidden) : 서버가 요청을 이해했지만 승인을 거부함.
  -> 주로 이 에러는 인증 자격 증명은 있지만, 접근 권한이 불충분한 경우에 발생.
  -> 예를들면 어드민 등급이 아닌 사용자가 어드민 권한에 접근할때.
- 404 (Not Found) : 요청 리소스를 찾을 수 없음.
  -> 요청 리소스가 서버에 없을때.
  -> 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을 때.
  500번때 : 서버의 내부적이 오류로 서버가 정상 요청을 처리하지 못할때.
- 500 (Internal Server Error) : 서버 문제로 오류 발생, 애매하면 500 오류
  -> 서버 내부 문제로 오류 발생할 때.
  -> 애매한 오류면 500에러내기.
- 503 (Service Unavailable) : 서비스 이용 불가.
  -> 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없을때.
  -> Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼수도 있다.

리다이렉션이란
- 영구 리다이렉션 : 특정 리소스의 URI가 영구적으로 이동.(301, 308)
- 일시 리다이렉션 : 특정 리소스의 URI가 일시적인 변경.(302, 303, 307)
* PRG(Post/Redirect/Get) : 일시적인 리다이렉션 예시
  1. (클라) 서버로 POST /order URL을 호출하여 주문.
  2. (서버) DB에 주문데이터 저장(mouse)
  3. (서버) 응답 데이터로 클라이언트에 URL : /order-result/10 이라고 전송(10은 mouse 생성된 값)
  4. (클라) 받은 값으로 자동 리다이렉트됨.
  5. (클라) 받은 URL 값으로 서버에 GET으로 /order-result/10를 전송.
  6. (서버) DB에 주문데이터 10번 조회.
  7. (서버) 클라이언트로 200 OK 응답.
  8. (클라) 결과화면에서 새로고침해도 GET /order-result/10 결과만 다시 요청됨.(5번 반복)
  9. 결과적으로 일시적 리다이렉션을 통해 재 주문이 되지않음.
- 특수 리다이렉션 : 결과 대신 캐시를 사용.(300, 304)

----------------------------------------------------------------------------------------------------------------------

※ 5일차 ※

* 일반 헤더

Header 일반정보
From (일반적으로 잘 사용되지 않음.
- 유저 에이전트의 이메일 정보
- 검색 엔진 같은 곳에서 사용
- 내 사이트 크롤링 같은거 못하게 하던가 할때.
  Referer
- 이전 사이트 웹 페이지 주소
- A에서 B로 이동하는 경우 Referer:A를 포함하여 요청함.
- 유입 경로 분석 가능.
  User-Agent
- 클라이언트의 애플리케이션 정보(웹 브라우저 정보 등)
- 통계정보
- 어떤 브라우저에서 장애가 발생하는 파악가능.
  Server
- 오리진 서버(진짜 나의 요청이 있는 마지막 서버)의 소프트웨어 정보
- Apache/2.2.22 (Debian)
  Date
- 메세지가 발생한 날짜와 시간
- 현재는 응답에서만 사용함.

Header 특별정보
Host
- 필수 값
- 요청한 호스트 정보
- 하나의 서버에 여러개의 도메인이 있을때.
  Location
- 300번 대의 응답 결과에 Location헤더가 있으면 자동 리다이렉트 함.(요청을 자동으로 리다이렉션하기 위한 값임.)
- 201(Created)때에는 생성된 리소스 URI를 뜻함.
  Allow
- 허용 가능한 HTTP 메서드를 알려줌.
- 405(Method Not Allowed)에서 응답에 포함해야함.
- Allow: GET, HEAD, PUT.
  Retry-After
- 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간.
- 503(Service Unavailable) : 서비스가 언제까지 불가능 한지 알려줄 수 있음.
- Retry-after : Fri, 31 Dec 1999 23:59:59 GMT / Retry-after : 120 (초단위 표기)

인증
Authoriztion : Basuc xxxxxxxxxxxxxxxxxxx
WWW-Authenticate
- 리소스 접근시 필요한 인증 방법 정의
- 401(Unauthorized) 응답과 함게 사용
  -> WWW-Authenticate : Newauth realm="apps", type=1, title="Login to \"apps\"", Basic realm="simple"

쿠키
사용처
- 사용자 로그인 세션 관리.
- 광고 정보 트레킹.
- 보안에 민감한 데이터는 절대 저장하면 안됨.
  쿠키 정보는 항상 서버에 전송됨.
- 네트워크 트래픽 추가 유발.(계속 쿠키정보는 넘어가기때문.)
- 최소한의 정보만 사용(세션ID, 인증 토큰 등)
- 클라이언트 자바스크립트 로직에서 사용할거면 웹스토리지(localStorage, sessionStorage)에서 사용
  Set-Cookie
- set-cookie: sessionId=abcde1234; expires=Sat, 26-Dec-2020 00:00:00 GMT; path=/; domain=.google.com;Secure
- 로그인이 성공되면 Session 키라는걸 생성하여 데이터베이스에 저장해놓고 클라이언트로 Set-cookie로 쿠키정보를 반환해줌.
  생명주기
- 세션 쿠키 : 만료 날짜를 생략하면 브라우저 종료시 까지만 유지.
- 만료 날짜를 입력하면 해당 날짜까지 유지.
  -> 만료일이 되면 쿠키삭제 (Set-Cookie: expires=지난날짜)
  -> 초단위로 지정할 수 있고 0이나 음수를 지정하면 쿠키삭제 (Set-Cookie: max-age=3600)
  도메인
- domain=naver.com 라고 명시하면
  -> naver.com도 접근되고
  -> email.naver.com도 접근가능
- 도메인을 생략할 경우
  -> 해당 쿠키를 생성하였던 곳에서만 쿠키 접근 가능.
  경로
- 해당 경로를 포함한 하위 경로 페이지만 쿠키 접근 가능
- path=/home
  -> /home 가능
  -> /home/level1/level2 가능
  -> /hello 불가능
  보완
  Secure
  - Secure를 넣으면 https인 경우에만 전송.
  - 없으면 http, https 구분 안함.
  HttpOnly
  - XSS 공격방지
  - 자바스크립트에서 접근 불가.(document.cookie)
  - HTTP 전송에만 사용.
  SameSite
  - XSRF 공격 방지
  - 요청 도메인과 쿠키게 설정된 도메인이 같은 경우만 쿠키 전송.
  - 추가된지 얼마안되서 지원 하는지 한번 확인해보고 사용해야함.

캐시 기본 동작
cache-control: max-age=60 하면 서버에서 받은 값을 60초동안은 캐쉬에 저장하여 캐쉬에서 꺼내서 값으로 사용함.

캐쉬가 만료되서 다시 받을때 서버와 데이터가 변경되지 않았을경우.
1. 브라우저 캐쉬는 Last-Modified: 2022-04-02 17:00:00 일때
2. 서버로 캐쉬시간 초과되어 보낼경우 if-modified-since: 2022-04-02 17:00:00
3. 만약 캐쉬의 마지막 수정일과 서버에서 데이터 최종수정일과 비교하여 변경되지 않았다면.
4. 서버에서 클라이언트로 304(Not Modified) 로 헤더 메타 정보만 재전송함.
5. 응답 결과를 브라우저 캐쉬에서 재사용, 캐시의 메타 정보 갱신.

ETag(Entity Tag)
- 위와 같이  if-modified-since: 2022-04-02 17:00:00로 한것처럼.
- ETag를 사용하여 현재 ETag: "aaaaaaaaaaaaa" 를 보내 서버에서 관리하는 ETag와 같은지만 보기도 함.
- 캐시 제어 로직을 서버에서 완전히 관리함.
- 사용 예
  -> 서버는 베타 오픈 기간인 3일 동안 파일이 변경되어도 ETag는 동일하게 유지함.
  -> 애플리케이션 배포 주기에 맞춰 ETag도 모두 갱신.

검증 헤더와 조건부 요청
검증 헤더
- 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
- Last-Modified, ETag
  조건부 요청 헤더
- 검증 헤더로 조건에 따른 분기
- If-Modified-Since, If-Unmodified-Since: Last-Modified 사용
- if-Match, If-None_match: ETag 사용
- 조건이 만족하면 200(OK)
- 조건이 만족하지 않으면 304(Not Modified)

Cache-Control(캐시 지시어)
Cache-Control: max-age
- 캐시 유효시간, 초단위
  Cache-Control: no-cache
- 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증받아 사용.
  Cache-Control: no-store
- 데이터에 민감한 정보가 있으므로 저장하면 안됨.
  Cache-Control: private (디폴트)
- 응답이 해당 사용자만을 위한 것임. private 캐시에 저장해야 함
  Cache-Control: public
- 응답이 public 캐시에 저장되어도 됨.
  Cache-Control: s-maxage
- 프록시 캐시에만 적용되는 max-age
  Age: 60 (초 단위)
- 오리진 서버에서 응답 후 프록시 캐시 내에서 머문 시간
  Cache-Control: must-revalidate
- must-revalidate는 캐시 유효 시간이라면 캐시를 사용함.
- 캐시 만료후 최초 조회시 원서버에 검증해야함.
- 원 서버 접근 실패시 반드시 오류가 발생해야 함. - 504(Gateway Timeout)

확실하게 캐시를 무효화 하기 위할때에는
-> Cache-Control: no-cache, no-store, must-revalidate
-> Pragma : no-cache (HTTP1.0 하위 호환을 위해 같이 넣어줌.)

must-revalidate는 원 서버에 접근 할 수 없는 경우, 항상 오류가 발생
no-cache는 서버 설정에 따라 캐시 데이터를 반황 할 수 있음.(오류 보다는 오래된 데이터라도 보여주자)

프록시 캐시 도입
- 미국에 원서버(원래 자원과 리소스가 있는 서버)가 있을경우 한국 어딘가에 프록시 캐시 서버가 있다면 한국 프록시 캐시에서 호출함.








