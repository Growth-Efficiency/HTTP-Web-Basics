※ 1일차 ※

TCP :
- 연결지향 - TCP 3 way handshake (가상 연결)
  -> 1. 상대에게 접속 요청을 보냄.
  -> 2. 요청 수락 및 접속 요청을 나에게 보냄.
  -> 3. 요청 수락 및 데이터 전송가능.
- 데이터 전달 보증
  -> 데이터 전송하면 데이터 잘 받았다고 결과를 줌.
- 순서보장
  -> 패킷1, 패킷3, 패킷2 이렇게 들어올 경우 패킷2부터 다시 보내라고 함.

UDP :
- 하얀 도화지와 같다(기능이 거의 없음)
- TCP는 이미 기반으로 쓰고 있기 때문에 개인적으로 최적화 등 쓰고 바꿔 쓰고 싶을때 사용한다.

PORT
TCP/IP 패킷내에 출발지IP와 PORT가 있고 해당 정보를 꺼내서 찾는다.
아파트의 몇호 처럼 한IP가 아파트, 한 PC가 한 호라고 생각하면 된다.

DNS
DNS서버에 도메인을 돈주고 사면 IP대신 도메인 명으로 사용할 수 있다.


URI(Uniform Resource Identifier)
Uniform : 리소스를 식별하는 통일된 방식
Resource : 자원, URI로 식별할 수 있는 모든것(제한 없음)
- 실시간 교통정보라던가 구분할 수 있는 모든 정보.
  Identifier : 다른 항목과 구분하는데 필요한 정보
- 주문번호로 구분한다던가 하면 주문번호가 Identifier가 될 수 있음.

- URI 라는 가장 큰 개념이 있다.
- URI는 URL(로테이터 = locator), URN(이름 = name) 또는 둘다로 분류될 수 있다.

URL(Uniform Resourcec Locator)
- 리소스가 있는 위치를 지정한다.
- URL은 변할 수 있다.
  URN(Uninform Resource Name)
- 리소스에 이름을 부여한다.
- URN은 변하지 않는다.
- URN 이름만으로 실제 리소스를 찾는 방법이 보편화 되있지 않다.

http는 80포트, https는 443포트를 주로 사용한다.

![저장](https://user-images.githubusercontent.com/54700818/159712523-df3f42ea-dc87-4d6d-9f7f-6f7400bbb599.PNG)

----------------------------------------------------------------------------------------------------------------------

※ 2일차 ※

Stateful : 상태유지
- 중간에 다른 점원으로 바뀌면 안된다.
- 로그인해야 되는 페이지.(브라우저 쿠키와 서버 세션 등)
- 상태유지는 최소한만 사용.
  Stateless : 무상태
- 갑자기 고객이 증가해도 점원을 대거 투입할 수 있다.
- 예를들면 단순한 이벤트 소개하는 페이지
- 데이터를 너무 많이 먹음.

비 연결성(connectionless)
- HTTP는 기본적으로 연결이 유지되지 않음.
- 서버의 자원을 효율적으로 사용 할 수 있음.
- TCP/IP 연결을 새로 맺어야 함.(3 way handshake 시간 추가.)
  -> 지금은 HTTP의 지속연결로 해결함.

지금은 HTTP 시대이다.

----------------------------------------------------------------------------------------------------------------------

※ 3일차 ※

Representation리소스란 무엇일까?
회원 등록시 회원이라는 개념 자체가 리소스이다.

리소스를 식별하는것이 가장 중요한데.(URI는 리소스만 식별해야 한다.)

회원 등록, 수정, 조회등의 URI를 설계하는것을 배제하고
회원이라는 리소스만 식별하여 URI에 매핑해야 한다.

GET : 리소스 조회
- 클라이언트가 리소스의 위치를 모름.
  POST : 주로 리소스 등록(요청 데이터 처리)
- 클라이언트가 리소스의 위치를 모름.
- 신규 등록
- 단순히 데이터를 생성하거나 변경하는것을 넘어선 프로세스를 처리해야 할 경우.
- JSON으로 조회 데이터를 넘겨야 해서 GET으로는 사용하기 어려울경우.
  PUT : 리소스 대체(없으면 생성)
- (중요) 클라이언트가 리소스의 위치를 알고 URI로 지정함.
- 폴더에 파일을 덮어씌우듯 완전히 대체함.
- 다른 필드 값이든 뭐든 그냥 내가 보낸 데이터로 완전히 덮어씌워버림(기존껀 싹 없애버림)
  PATCH : 리소스 부분 변경
- (중요) 클라이언트가 리소스의 위치를 알고 URI로 지정함.
- 리소스의 부분 값을 바꾸고 싶으면 PATCH를 쓰면 됨.
  DELETE : 리소스 삭제
- (중요) 클라이언트가 리소스의 위치를 알고 URI로 지정함.
- 리소스를 삭제함.

HEAD : GET과 동일.(결과값은 상태줄과 헤더만 줘)
OPTIONS : 리소스에 대한 통신 가능 옵션을 설명 -> 주로 CORS에서 사용
CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정 -> 잘 사용하지 않음.
TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행 -> 잘 사용하지 않음.

![http](https://user-images.githubusercontent.com/54700818/160238332-8b32db75-fbb2-400d-ad88-825146b4b27e.PNG)

안전(Safe) : 여러번 호출했을때 리소스가 변하지 않아야 한다.
멱등(Idempotent) : 한번 호출하든 100번 호출하든 결과가 같아야 한다.
- (실행 응답 결과가 오지 않았을때 자동으로 다시 실행 시켜도 되는지 같은 경우.)
- (예를들면 GET등 외부요인으로 중간에 리소스가 변경되는것 까지는 판단하지 않음.)
- GET : 같은 요청을 하면 같은 값이므로 결과가 멱등함.
- PUT : 같은 요청을 해도 항상 같은 값을 대체하므로 결과가 멱등함.
- DELETE : 결과를 삭제하는건 같으므로 여러번 삭제해도 결과가 멱등함.
- POST : 멱등이 아님! 중복해서 로직등이 실행 됨.

캐시가능(Cacheable) : 응답 결과를 캐쉬에서 사용할 수 있는지.
- GET, HEAD, POST, PATCH는 캐쉬 가능.
- 실제로는 GET, HEAD 정도만 캐쉬로 사용함.
- POST, PATCH는 body 내용도 구별을 해야하기 때문에 잘 구현해놓지 않음.

클라이언트에서 서버로 데이터 전송시 4가지 상황
1. 정적 데이터 조회(이미지, 텍스트 등)
- 조회는 GET사용.
- 보통 쿼리 파마리터 없이 리소스 경로로 단순하게 조회.
2. 동적 데이터 조회
- 조회는 GET사용.
- 쿼리 파마리터 사용.
- 주로 검색, 게시판 목록에서 정렬 필터(검색어)
3. HTML Form 데이터 전송
- <form action="/save" method="get">안에 username, age가 <input> 태그이면 GET /save?username=kim&age=20 HTTP/1.1 이런식으로 생성됨.
- action = URI, method = GET,POST 등.
- POST의 경우 body username=kim&age=20가 생성됨.
- <form>에 enctype="multipart/form-data"를 넣으면 파일도 전송이 가능하다.

4. HTTP API 데이터 전송
- 서버끼리 통실 할 때 사용.(기계끼리 통신)
- 앱 클라이언트(아이폰, 안드로이드)
- 웹 클라이언트(자바스크립트를 통한 통신 : Ajax)
  -> 메시지 body를 통해 데이터 전송.(POST, PUT, PATCH)
  -> 쿼리 파라미터로 데이터 전달.(GET, 정렬 검색)

